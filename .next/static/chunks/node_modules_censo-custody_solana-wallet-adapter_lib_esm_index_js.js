/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_censo-custody_solana-wallet-adapter_lib_esm_index_js"],{

/***/ "./node_modules/@censo-custody/solana-wallet-adapter/node_modules/base-x/src/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@censo-custody/solana-wallet-adapter/node_modules/base-x/src/index.js ***!
  \********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNlbnNvLWN1c3RvZHkvc29sYW5hLXdhbGxldC1hZGFwdGVyL25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzRkFBNkI7QUFDM0M7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUscUNBQXFDO0FBQ3JDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWSxTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSwrQkFBK0IsNkNBQTZDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjZW5zby1jdXN0b2R5L3NvbGFuYS13YWxsZXQtYWRhcHRlci9ub2RlX21vZHVsZXMvYmFzZS14L3NyYy9pbmRleC5qcz84YjI4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuLy8gYmFzZS14IGVuY29kaW5nIC8gZGVjb2Rpbmdcbi8vIENvcHlyaWdodCAoYykgMjAxOCBiYXNlLXggY29udHJpYnV0b3JzXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCBUaGUgQml0Y29pbiBDb3JlIGRldmVsb3BlcnMgKGJhc2U1OC5jcHApXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIExJQ0VOU0Ugb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG4vLyBAdHMtaWdub3JlXG52YXIgX0J1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5mdW5jdGlvbiBiYXNlIChBTFBIQUJFVCkge1xuICBpZiAoQUxQSEFCRVQubGVuZ3RoID49IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHBoYWJldCB0b28gbG9uZycpIH1cbiAgdmFyIEJBU0VfTUFQID0gbmV3IFVpbnQ4QXJyYXkoMjU2KVxuICBmb3IgKHZhciBqID0gMDsgaiA8IEJBU0VfTUFQLmxlbmd0aDsgaisrKSB7XG4gICAgQkFTRV9NQVBbal0gPSAyNTVcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHggPSBBTFBIQUJFVC5jaGFyQXQoaSlcbiAgICB2YXIgeGMgPSB4LmNoYXJDb2RlQXQoMClcbiAgICBpZiAoQkFTRV9NQVBbeGNdICE9PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBhbWJpZ3VvdXMnKSB9XG4gICAgQkFTRV9NQVBbeGNdID0gaVxuICB9XG4gIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoXG4gIHZhciBMRUFERVIgPSBBTFBIQUJFVC5jaGFyQXQoMClcbiAgdmFyIEZBQ1RPUiA9IE1hdGgubG9nKEJBU0UpIC8gTWF0aC5sb2coMjU2KSAvLyBsb2coQkFTRSkgLyBsb2coMjU2KSwgcm91bmRlZCB1cFxuICB2YXIgaUZBQ1RPUiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKSAvLyBsb2coMjU2KSAvIGxvZyhCQVNFKSwgcm91bmRlZCB1cFxuICBmdW5jdGlvbiBlbmNvZGUgKHNvdXJjZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkgeyBzb3VyY2UgPSBfQnVmZmVyLmZyb20oc291cmNlKSB9XG4gICAgaWYgKCFfQnVmZmVyLmlzQnVmZmVyKHNvdXJjZSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgQnVmZmVyJykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJyB9XG4gICAgICAgIC8vIFNraXAgJiBjb3VudCBsZWFkaW5nIHplcm9lcy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgdmFyIHBiZWdpbiA9IDBcbiAgICB2YXIgcGVuZCA9IHNvdXJjZS5sZW5ndGhcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kICYmIHNvdXJjZVtwYmVnaW5dID09PSAwKSB7XG4gICAgICBwYmVnaW4rK1xuICAgICAgemVyb2VzKytcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2U1OCByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgocGVuZCAtIHBiZWdpbikgKiBpRkFDVE9SICsgMSkgPj4+IDBcbiAgICB2YXIgYjU4ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgYnl0ZXMuXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCkge1xuICAgICAgdmFyIGNhcnJ5ID0gc291cmNlW3BiZWdpbl1cbiAgICAgICAgICAgIC8vIEFwcGx5IFwiYjU4ID0gYjU4ICogMjU2ICsgY2hcIi5cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQxID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQxICE9PSAtMSk7IGl0MS0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKDI1NiAqIGI1OFtpdDFdKSA+Pj4gMFxuICAgICAgICBiNThbaXQxXSA9IChjYXJyeSAlIEJBU0UpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gQkFTRSkgPj4+IDBcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaVxuICAgICAgcGJlZ2luKytcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYmFzZTU4IHJlc3VsdC5cbiAgICB2YXIgaXQyID0gc2l6ZSAtIGxlbmd0aFxuICAgIHdoaWxlIChpdDIgIT09IHNpemUgJiYgYjU4W2l0Ml0gPT09IDApIHtcbiAgICAgIGl0MisrXG4gICAgfVxuICAgICAgICAvLyBUcmFuc2xhdGUgdGhlIHJlc3VsdCBpbnRvIGEgc3RyaW5nLlxuICAgIHZhciBzdHIgPSBMRUFERVIucmVwZWF0KHplcm9lcylcbiAgICBmb3IgKDsgaXQyIDwgc2l6ZTsgKytpdDIpIHsgc3RyICs9IEFMUEhBQkVULmNoYXJBdChiNThbaXQyXSkgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUgKHNvdXJjZSkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBTdHJpbmcnKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuIF9CdWZmZXIuYWxsb2MoMCkgfVxuICAgIHZhciBwc3ogPSAwXG4gICAgICAgIC8vIFNraXAgYW5kIGNvdW50IGxlYWRpbmcgJzEncy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdID09PSBMRUFERVIpIHtcbiAgICAgIHplcm9lcysrXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTI1NiByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgoKHNvdXJjZS5sZW5ndGggLSBwc3opICogRkFDVE9SKSArIDEpID4+PiAwIC8vIGxvZyg1OCkgLyBsb2coMjU2KSwgcm91bmRlZCB1cC5cbiAgICB2YXIgYjI1NiA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGNoYXJhY3RlcnMuXG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdKSB7XG4gICAgICAgICAgICAvLyBEZWNvZGUgY2hhcmFjdGVyXG4gICAgICB2YXIgY2FycnkgPSBCQVNFX01BUFtzb3VyY2UuY2hhckNvZGVBdChwc3opXVxuICAgICAgICAgICAgLy8gSW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgIGlmIChjYXJyeSA9PT0gMjU1KSB7IHJldHVybiB9XG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MyAhPT0gLTEpOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IChCQVNFICogYjI1NltpdDNdKSA+Pj4gMFxuICAgICAgICBiMjU2W2l0M10gPSAoY2FycnkgJSAyNTYpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gMjU2KSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiMjU2LlxuICAgIHZhciBpdDQgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrXG4gICAgfVxuICAgIHZhciB2Y2ggPSBfQnVmZmVyLmFsbG9jVW5zYWZlKHplcm9lcyArIChzaXplIC0gaXQ0KSlcbiAgICB2Y2guZmlsbCgweDAwLCAwLCB6ZXJvZXMpXG4gICAgdmFyIGogPSB6ZXJvZXNcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdXG4gICAgfVxuICAgIHJldHVybiB2Y2hcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUgKHN0cmluZykge1xuICAgIHZhciBidWZmZXIgPSBkZWNvZGVVbnNhZmUoc3RyaW5nKVxuICAgIGlmIChidWZmZXIpIHsgcmV0dXJuIGJ1ZmZlciB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24tYmFzZScgKyBCQVNFICsgJyBjaGFyYWN0ZXInKVxuICB9XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gICAgZGVjb2RlOiBkZWNvZGVcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBiYXNlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@censo-custody/solana-wallet-adapter/node_modules/base-x/src/index.js\n");

/***/ }),

/***/ "./node_modules/@censo-custody/solana-wallet-adapter/node_modules/bs58/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@censo-custody/solana-wallet-adapter/node_modules/bs58/index.js ***!
  \**************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var basex = __webpack_require__(/*! base-x */ \"./node_modules/@censo-custody/solana-wallet-adapter/node_modules/base-x/src/index.js\")\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNlbnNvLWN1c3RvZHkvc29sYW5hLXdhbGxldC1hZGFwdGVyL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFlBQVksbUJBQU8sQ0FBQyxvR0FBUTtBQUM1Qjs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNlbnNvLWN1c3RvZHkvc29sYW5hLXdhbGxldC1hZGFwdGVyL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzPzQ5ZjYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGJhc2V4ID0gcmVxdWlyZSgnYmFzZS14JylcbnZhciBBTFBIQUJFVCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2V4KEFMUEhBQkVUKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@censo-custody/solana-wallet-adapter/node_modules/bs58/index.js\n");

/***/ }),

/***/ "./node_modules/@censo-custody/solana-wallet-adapter/lib/esm/censocustody.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@censo-custody/solana-wallet-adapter/lib/esm/censocustody.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CensoWallet\": function() { return /* binding */ CensoWallet; }\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bs58 */ \"./node_modules/@censo-custody/solana-wallet-adapter/node_modules/bs58/index.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\n\nconst DEFAULT_SIGNATURE_BUFFER = Buffer.alloc(_solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SIGNATURE_LENGTH_IN_BYTES).fill(0);\nclass CensoWallet extends eventemitter3__WEBPACK_IMPORTED_MODULE_2__.EventEmitter {\n    constructor() {\n        super();\n        this.url = 'https://wallet.censocustody.com';\n        this.cleanUp = () => {\n            [...this._timers].forEach(t => this.clearTimer(t));\n            const wallet = this._wallet;\n            if (wallet) {\n                wallet.close();\n            }\n            this._wallet = null;\n            this.emit('disconnected');\n        };\n        this.clearTimer = (timer) => {\n            this._timers = this._timers.filter(t => t != timer);\n            window.clearInterval(timer);\n        };\n        this.instructionsToSerializableInstructions = (instructions) => instructions.map(i => {\n            return {\n                'programId': i.programId.toBase58(),\n                'accountMetas': i.keys.map(k => {\n                    return {\n                        address: k.pubkey.toBase58(),\n                        signer: k.isSigner,\n                        writable: k.isWritable,\n                    };\n                }),\n                'data': window.btoa(String.fromCharCode(...i.data)),\n            };\n        });\n        this.handleWalletMessage = (data) => {\n            var _a, _b, _c;\n            if (data.type == \"connected\") {\n                this._connecting = false;\n                if (!data.error) {\n                    this.isLoggedIn = true;\n                    if ((_a = data.connected) === null || _a === void 0 ? void 0 : _a.publicKey) {\n                        this._publicKey = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(data.connected.publicKey);\n                    }\n                }\n            }\n            else if ([\"sendTransaction\", \"sendFinalTransaction\"].includes(data.type)) {\n                const transactionIdentifier = (_b = data.sendTransaction) === null || _b === void 0 ? void 0 : _b.identifier;\n                if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n                    if (data.error) {\n                        this._pendingTransactionErrors[transactionIdentifier] = { message: data.error };\n                    }\n                    else {\n                        this._pendingTransactions[transactionIdentifier] = data.sendTransaction || null;\n                    }\n                }\n            }\n            else if (data.type == \"signTransaction\") {\n                const transactionIdentifier = (_c = data.signTransaction) === null || _c === void 0 ? void 0 : _c.identifier;\n                if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n                    if (data.error) {\n                        this._pendingTransactionErrors[transactionIdentifier] = { message: data.error };\n                    }\n                    else {\n                        this._pendingTransactions[transactionIdentifier] = data.signTransaction || null;\n                    }\n                }\n            }\n        };\n        this.isLoggedIn = false;\n        this._pendingTransactions = {};\n        this._pendingTransactionErrors = {};\n        this._timers = [];\n        this._wallet = null;\n        this._connecting = false;\n        this._publicKey = null;\n        window.addEventListener(\"message\", (e) => {\n            this.handleWalletMessage(e.data);\n        });\n    }\n    async connect(url) {\n        try {\n            this.url = url || this.url;\n            const origin = encodeURIComponent(window.location.origin);\n            const connectUrl = `${this.url}/connect?origin=${origin}`;\n            this._connecting = true;\n            this._wallet = window.open(connectUrl, `censo-custody-${origin}`, \"height=900,width=800,menubar=no,status=no,toolbar=no\");\n            if (!this._wallet) {\n                this._connecting = false;\n                throw new Error(\"Unable to connect to wallet\");\n            }\n            this._timers.push(window.setInterval(() => {\n                if (this._wallet.closed) {\n                    this.cleanUp();\n                }\n                else if (this._wallet) {\n                    this._wallet.postMessage({ type: 'heartbeat' }, this.url);\n                }\n            }, 100));\n            return new Promise((resolve, reject) => {\n                const timer = window.setInterval(() => {\n                    if (this.isLoggedIn && this._publicKey) {\n                        this.clearTimer(timer);\n                        resolve(this._publicKey);\n                    }\n                    else if (!this.isLoggedIn && !this._connecting) {\n                        this.clearTimer(timer);\n                        reject(new Error(\"Unable to connect to Censo\"));\n                    }\n                }, 100);\n                this._timers.push(timer);\n            });\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    async signTransaction(transaction) {\n        this.verifyCanSignRequests([transaction]);\n        try {\n            return this.signOneTransaction(transaction);\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    async signAllTransactions(transactions) {\n        this.verifyCanSignRequests(transactions);\n        try {\n            return this.signMultipleTransactions(transactions);\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    async sendTransaction(transaction, connection, options) {\n        try {\n            const wallet = this._wallet;\n            if (!wallet)\n                throw new Error(\"Not Connected\");\n            const transactionIdentifier = (0,uuid__WEBPACK_IMPORTED_MODULE_3__.v4)();\n            this._pendingTransactions[transactionIdentifier] = null;\n            const signers = options ? options.signers : undefined;\n            if (signers && signers.length > 0) {\n                return new Promise((resolve, reject) => {\n                    this.signOneTransaction(transaction, transactionIdentifier).then(walletTransaction => {\n                        this._pendingTransactions[transactionIdentifier] = null;\n                        (signers === null || signers === void 0 ? void 0 : signers.length) && walletTransaction.partialSign(...signers);\n                        wallet.postMessage({\n                            type: \"sendFinalTransaction\", sendFinalTransaction: {\n                                transactionIdentifier,\n                                signaturePubkeyPairs: walletTransaction.signatures.filter(sp => sp.signature != null).map(sp => {\n                                    return {\n                                        'pubkey': sp.publicKey.toBase58(),\n                                        'signature': sp.signature.toString('base64')\n                                    };\n                                })\n                            }\n                        }, this.url);\n                        const timer = window.setInterval(() => {\n                            const pendingTransaction = this._pendingTransactions[transactionIdentifier];\n                            const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier];\n                            if (pendingTransaction != null || pendingTransactionError != null) {\n                                this.clearTimer(timer);\n                                pendingTransaction && resolve(pendingTransaction.signature);\n                                pendingTransactionError && reject(pendingTransactionError);\n                            }\n                        }, 100);\n                        this._timers.push(timer);\n                    }).catch((error) => {\n                        reject(error);\n                        throw error;\n                    });\n                });\n            }\n            else {\n                const instructions = this.instructionsToSerializableInstructions(transaction.instructions);\n                return new Promise((resolve, reject) => {\n                    wallet.postMessage({\n                        type: \"sendTransaction\",\n                        sendTransaction: { instructions, transactionIdentifier }\n                    }, this.url);\n                    const timer = window.setInterval(() => {\n                        const pendingTransaction = this._pendingTransactions[transactionIdentifier];\n                        const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier];\n                        if (pendingTransaction != null || pendingTransactionError != null) {\n                            this.clearTimer(timer);\n                            pendingTransaction && resolve(pendingTransaction.signature);\n                            pendingTransactionError && reject(pendingTransactionError);\n                        }\n                    }, 100);\n                    this._timers.push(timer);\n                });\n            }\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    buildTransaction(pendingTransaction) {\n        let message = _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Message.from(Buffer.from(Uint8Array.from(window.atob(pendingTransaction.message), c => c.charCodeAt(0))));\n        return _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.populate(message, Array.from({ length: message.header.numRequiredSignatures }, (_v, i) => {\n            let sigPubkeyPair = pendingTransaction.signatures.find(s => s.pubkey == message.accountKeys[i].toBase58());\n            return bs58__WEBPACK_IMPORTED_MODULE_1__.encode(sigPubkeyPair\n                ? Buffer.from(Uint8Array.from(window.atob(sigPubkeyPair.signature), c => c.charCodeAt(0)))\n                : DEFAULT_SIGNATURE_BUFFER);\n        }));\n    }\n    verifyCanSignRequests(transactions) {\n        transactions.forEach(transaction => {\n            if (transaction.signatures.some(s => s.signature != null)) {\n                throw new Error(\"Censo does not support this signing mode\");\n            }\n        });\n    }\n    signOneTransaction(transaction, transactionIdentifier = (0,uuid__WEBPACK_IMPORTED_MODULE_3__.v4)()) {\n        const wallet = this._wallet;\n        if (!wallet)\n            throw new Error(\"Not Connected\");\n        const instructions = this.instructionsToSerializableInstructions(transaction.instructions);\n        this._pendingTransactions[transactionIdentifier] = null;\n        return new Promise((resolve, reject) => {\n            wallet.postMessage({ type: \"signTransaction\", signTransaction: { instructions, transactionIdentifier } }, this.url);\n            const timer = window.setInterval(() => {\n                const pendingTransaction = this._pendingTransactions[transactionIdentifier];\n                const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier];\n                if (pendingTransaction != null || pendingTransactionError != null) {\n                    this.clearTimer(timer);\n                    pendingTransaction && resolve(this.buildTransaction(pendingTransaction));\n                    pendingTransactionError && reject(pendingTransactionError);\n                }\n            }, 100);\n            this._timers.push(timer);\n        });\n    }\n    signMultipleTransactions(transactions) {\n        const wallet = this._wallet;\n        if (!wallet)\n            throw new Error(\"Not Connected\");\n        const serializedTransactions = transactions.map((t) => {\n            return {\n                instructions: this.instructionsToSerializableInstructions(t.instructions),\n                transactionIdentifier: (0,uuid__WEBPACK_IMPORTED_MODULE_3__.v4)()\n            };\n        });\n        const transactionIdentifiers = serializedTransactions.map((t) => t.transactionIdentifier);\n        transactionIdentifiers.forEach((transactionIdentifier) => this._pendingTransactions[transactionIdentifier] = null);\n        return new Promise((resolve, reject) => {\n            wallet.postMessage({ type: \"signAllTransactions\", signAllTransactions: { transactions: serializedTransactions } }, this.url);\n            const timer = window.setInterval(() => {\n                const pendingTransactions = transactionIdentifiers.map((txId) => this._pendingTransactions[txId]);\n                const pendingTransactionErrors = transactionIdentifiers.map((txId) => this._pendingTransactionErrors[txId]);\n                if (pendingTransactions.every((t) => t != null)) {\n                    this.clearTimer(timer);\n                    resolve(pendingTransactions.map((pt) => this.buildTransaction(pt)));\n                }\n                else if (pendingTransactionErrors.some((e) => e != null)) {\n                    this.clearTimer(timer);\n                    reject(pendingTransactionErrors.find((e) => e != null));\n                }\n            }, 100);\n            this._timers.push(timer);\n        });\n    }\n}\n//# sourceMappingURL=censocustody.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNlbnNvLWN1c3RvZHkvc29sYW5hLXdhbGxldC1hZGFwdGVyL2xpYi9lc20vY2Vuc29jdXN0b2R5LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE2RjtBQUNyRTtBQUNZO0FBQ1M7QUFDN0MsaUNBQWlDLE1BQU0sT0FBTyxzRUFBeUI7QUFDaEUsMEJBQTBCLHVEQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0RBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTLGtCQUFrQixPQUFPO0FBQ3BFO0FBQ0Esb0VBQW9FLE9BQU87QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG1CQUFtQjtBQUNsRTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx3Q0FBTTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseURBQVksQ0FBQyxNQUFNO0FBQ3pDLGVBQWUsaUVBQW9CLHVCQUF1Qiw4Q0FBOEM7QUFDeEc7QUFDQSxtQkFBbUIsd0NBQVc7QUFDOUIsa0JBQWtCLE1BQU07QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNERBQTRELHdDQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0Q0FBNEMsdUNBQXVDO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3Q0FBTTtBQUM3QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQW9ELHdDQUF3QztBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNlbnNvLWN1c3RvZHkvc29sYW5hLXdhbGxldC1hZGFwdGVyL2xpYi9lc20vY2Vuc29jdXN0b2R5LmpzPzc0MjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWVzc2FnZSwgUHVibGljS2V5LCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTLCBUcmFuc2FjdGlvbiB9IGZyb20gXCJAc29sYW5hL3dlYjMuanNcIjtcbmltcG9ydCBiczU4IGZyb20gXCJiczU4XCI7XG5pbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSBcImV2ZW50ZW1pdHRlcjNcIjtcbmNvbnN0IERFRkFVTFRfU0lHTkFUVVJFX0JVRkZFUiA9IEJ1ZmZlci5hbGxvYyhTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKS5maWxsKDApO1xuZXhwb3J0IGNsYXNzIENlbnNvV2FsbGV0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy51cmwgPSAnaHR0cHM6Ly93YWxsZXQuY2Vuc29jdXN0b2R5LmNvbSc7XG4gICAgICAgIHRoaXMuY2xlYW5VcCA9ICgpID0+IHtcbiAgICAgICAgICAgIFsuLi50aGlzLl90aW1lcnNdLmZvckVhY2godCA9PiB0aGlzLmNsZWFyVGltZXIodCkpO1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gdGhpcy5fd2FsbGV0O1xuICAgICAgICAgICAgaWYgKHdhbGxldCkge1xuICAgICAgICAgICAgICAgIHdhbGxldC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fd2FsbGV0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lciA9ICh0aW1lcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdGltZXJzID0gdGhpcy5fdGltZXJzLmZpbHRlcih0ID0+IHQgIT0gdGltZXIpO1xuICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmluc3RydWN0aW9uc1RvU2VyaWFsaXphYmxlSW5zdHJ1Y3Rpb25zID0gKGluc3RydWN0aW9ucykgPT4gaW5zdHJ1Y3Rpb25zLm1hcChpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3Byb2dyYW1JZCc6IGkucHJvZ3JhbUlkLnRvQmFzZTU4KCksXG4gICAgICAgICAgICAgICAgJ2FjY291bnRNZXRhcyc6IGkua2V5cy5tYXAoayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBrLnB1YmtleS50b0Jhc2U1OCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmVyOiBrLmlzU2lnbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IGsuaXNXcml0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAnZGF0YSc6IHdpbmRvdy5idG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uaS5kYXRhKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW5kbGVXYWxsZXRNZXNzYWdlID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzTG9nZ2VkSW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKF9hID0gZGF0YS5jb25uZWN0ZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wdWJsaWNLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXkoZGF0YS5jb25uZWN0ZWQucHVibGljS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFtcInNlbmRUcmFuc2FjdGlvblwiLCBcInNlbmRGaW5hbFRyYW5zYWN0aW9uXCJdLmluY2x1ZGVzKGRhdGEudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkZW50aWZpZXIgPSAoX2IgPSBkYXRhLnNlbmRUcmFuc2FjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlkZW50aWZpZXI7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uSWRlbnRpZmllciAmJiB0cmFuc2FjdGlvbklkZW50aWZpZXIgaW4gdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9uRXJyb3JzW3RyYW5zYWN0aW9uSWRlbnRpZmllcl0gPSB7IG1lc3NhZ2U6IGRhdGEuZXJyb3IgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdUcmFuc2FjdGlvbnNbdHJhbnNhY3Rpb25JZGVudGlmaWVyXSA9IGRhdGEuc2VuZFRyYW5zYWN0aW9uIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhLnR5cGUgPT0gXCJzaWduVHJhbnNhY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWRlbnRpZmllciA9IChfYyA9IGRhdGEuc2lnblRyYW5zYWN0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25JZGVudGlmaWVyICYmIHRyYW5zYWN0aW9uSWRlbnRpZmllciBpbiB0aGlzLl9wZW5kaW5nVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nVHJhbnNhY3Rpb25FcnJvcnNbdHJhbnNhY3Rpb25JZGVudGlmaWVyXSA9IHsgbWVzc2FnZTogZGF0YS5lcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbklkZW50aWZpZXJdID0gZGF0YS5zaWduVHJhbnNhY3Rpb24gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc0xvZ2dlZEluID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdUcmFuc2FjdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9uRXJyb3JzID0ge307XG4gICAgICAgIHRoaXMuX3RpbWVycyA9IFtdO1xuICAgICAgICB0aGlzLl93YWxsZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3B1YmxpY0tleSA9IG51bGw7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVXYWxsZXRNZXNzYWdlKGUuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBjb25uZWN0KHVybCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy51cmwgPSB1cmwgfHwgdGhpcy51cmw7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW4gPSBlbmNvZGVVUklDb21wb25lbnQod2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0VXJsID0gYCR7dGhpcy51cmx9L2Nvbm5lY3Q/b3JpZ2luPSR7b3JpZ2lufWA7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3dhbGxldCA9IHdpbmRvdy5vcGVuKGNvbm5lY3RVcmwsIGBjZW5zby1jdXN0b2R5LSR7b3JpZ2lufWAsIFwiaGVpZ2h0PTkwMCx3aWR0aD04MDAsbWVudWJhcj1ubyxzdGF0dXM9bm8sdG9vbGJhcj1ub1wiKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fd2FsbGV0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjb25uZWN0IHRvIHdhbGxldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RpbWVycy5wdXNoKHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dhbGxldC5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3dhbGxldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl93YWxsZXQucG9zdE1lc3NhZ2UoeyB0eXBlOiAnaGVhcnRiZWF0JyB9LCB0aGlzLnVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2dnZWRJbiAmJiB0aGlzLl9wdWJsaWNLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcih0aW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuX3B1YmxpY0tleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuaXNMb2dnZWRJbiAmJiAhdGhpcy5fY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVyKHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJVbmFibGUgdG8gY29ubmVjdCB0byBDZW5zb1wiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVycy5wdXNoKHRpbWVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Q2FuU2lnblJlcXVlc3RzKFt0cmFuc2FjdGlvbl0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbk9uZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNpZ25BbGxUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Q2FuU2lnblJlcXVlc3RzKHRyYW5zYWN0aW9ucyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduTXVsdGlwbGVUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwgb3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gdGhpcy5fd2FsbGV0O1xuICAgICAgICAgICAgaWYgKCF3YWxsZXQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IENvbm5lY3RlZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWRlbnRpZmllciA9IHV1aWR2NCgpO1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbklkZW50aWZpZXJdID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lcnMgPSBvcHRpb25zID8gb3B0aW9ucy5zaWduZXJzIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHNpZ25lcnMgJiYgc2lnbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWduT25lVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uSWRlbnRpZmllcikudGhlbih3YWxsZXRUcmFuc2FjdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nVHJhbnNhY3Rpb25zW3RyYW5zYWN0aW9uSWRlbnRpZmllcl0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNpZ25lcnMgPT09IG51bGwgfHwgc2lnbmVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2lnbmVycy5sZW5ndGgpICYmIHdhbGxldFRyYW5zYWN0aW9uLnBhcnRpYWxTaWduKC4uLnNpZ25lcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNlbmRGaW5hbFRyYW5zYWN0aW9uXCIsIHNlbmRGaW5hbFRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlUHVia2V5UGFpcnM6IHdhbGxldFRyYW5zYWN0aW9uLnNpZ25hdHVyZXMuZmlsdGVyKHNwID0+IHNwLnNpZ25hdHVyZSAhPSBudWxsKS5tYXAoc3AgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHVia2V5Jzogc3AucHVibGljS2V5LnRvQmFzZTU4KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NpZ25hdHVyZSc6IHNwLnNpZ25hdHVyZS50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy51cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdUcmFuc2FjdGlvbiA9IHRoaXMuX3BlbmRpbmdUcmFuc2FjdGlvbnNbdHJhbnNhY3Rpb25JZGVudGlmaWVyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nVHJhbnNhY3Rpb25FcnJvciA9IHRoaXMuX3BlbmRpbmdUcmFuc2FjdGlvbkVycm9yc1t0cmFuc2FjdGlvbklkZW50aWZpZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nVHJhbnNhY3Rpb24gIT0gbnVsbCB8fCBwZW5kaW5nVHJhbnNhY3Rpb25FcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcih0aW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdUcmFuc2FjdGlvbiAmJiByZXNvbHZlKHBlbmRpbmdUcmFuc2FjdGlvbi5zaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nVHJhbnNhY3Rpb25FcnJvciAmJiByZWplY3QocGVuZGluZ1RyYW5zYWN0aW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lcnMucHVzaCh0aW1lcik7XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zVG9TZXJpYWxpemFibGVJbnN0cnVjdGlvbnModHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRUcmFuc2FjdGlvbjogeyBpbnN0cnVjdGlvbnMsIHRyYW5zYWN0aW9uSWRlbnRpZmllciB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ1RyYW5zYWN0aW9uID0gdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbklkZW50aWZpZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ1RyYW5zYWN0aW9uRXJyb3IgPSB0aGlzLl9wZW5kaW5nVHJhbnNhY3Rpb25FcnJvcnNbdHJhbnNhY3Rpb25JZGVudGlmaWVyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nVHJhbnNhY3Rpb24gIT0gbnVsbCB8fCBwZW5kaW5nVHJhbnNhY3Rpb25FcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVyKHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nVHJhbnNhY3Rpb24gJiYgcmVzb2x2ZShwZW5kaW5nVHJhbnNhY3Rpb24uc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nVHJhbnNhY3Rpb25FcnJvciAmJiByZWplY3QocGVuZGluZ1RyYW5zYWN0aW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lcnMucHVzaCh0aW1lcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZFRyYW5zYWN0aW9uKHBlbmRpbmdUcmFuc2FjdGlvbikge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IE1lc3NhZ2UuZnJvbShCdWZmZXIuZnJvbShVaW50OEFycmF5LmZyb20od2luZG93LmF0b2IocGVuZGluZ1RyYW5zYWN0aW9uLm1lc3NhZ2UpLCBjID0+IGMuY2hhckNvZGVBdCgwKSkpKTtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uLnBvcHVsYXRlKG1lc3NhZ2UsIEFycmF5LmZyb20oeyBsZW5ndGg6IG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyB9LCAoX3YsIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBzaWdQdWJrZXlQYWlyID0gcGVuZGluZ1RyYW5zYWN0aW9uLnNpZ25hdHVyZXMuZmluZChzID0+IHMucHVia2V5ID09IG1lc3NhZ2UuYWNjb3VudEtleXNbaV0udG9CYXNlNTgoKSk7XG4gICAgICAgICAgICByZXR1cm4gYnM1OC5lbmNvZGUoc2lnUHVia2V5UGFpclxuICAgICAgICAgICAgICAgID8gQnVmZmVyLmZyb20oVWludDhBcnJheS5mcm9tKHdpbmRvdy5hdG9iKHNpZ1B1YmtleVBhaXIuc2lnbmF0dXJlKSwgYyA9PiBjLmNoYXJDb2RlQXQoMCkpKVxuICAgICAgICAgICAgICAgIDogREVGQVVMVF9TSUdOQVRVUkVfQlVGRkVSKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICB2ZXJpZnlDYW5TaWduUmVxdWVzdHModHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHRyYW5zYWN0aW9ucy5mb3JFYWNoKHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5zaWduYXR1cmVzLnNvbWUocyA9PiBzLnNpZ25hdHVyZSAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNlbnNvIGRvZXMgbm90IHN1cHBvcnQgdGhpcyBzaWduaW5nIG1vZGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduT25lVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uSWRlbnRpZmllciA9IHV1aWR2NCgpKSB7XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IHRoaXMuX3dhbGxldDtcbiAgICAgICAgaWYgKCF3YWxsZXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgQ29ubmVjdGVkXCIpO1xuICAgICAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9uc1RvU2VyaWFsaXphYmxlSW5zdHJ1Y3Rpb25zKHRyYW5zYWN0aW9uLmluc3RydWN0aW9ucyk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdUcmFuc2FjdGlvbnNbdHJhbnNhY3Rpb25JZGVudGlmaWVyXSA9IG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB3YWxsZXQucG9zdE1lc3NhZ2UoeyB0eXBlOiBcInNpZ25UcmFuc2FjdGlvblwiLCBzaWduVHJhbnNhY3Rpb246IHsgaW5zdHJ1Y3Rpb25zLCB0cmFuc2FjdGlvbklkZW50aWZpZXIgfSB9LCB0aGlzLnVybCk7XG4gICAgICAgICAgICBjb25zdCB0aW1lciA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ1RyYW5zYWN0aW9uID0gdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbklkZW50aWZpZXJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdUcmFuc2FjdGlvbkVycm9yID0gdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9uRXJyb3JzW3RyYW5zYWN0aW9uSWRlbnRpZmllcl07XG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdUcmFuc2FjdGlvbiAhPSBudWxsIHx8IHBlbmRpbmdUcmFuc2FjdGlvbkVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVyKHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1RyYW5zYWN0aW9uICYmIHJlc29sdmUodGhpcy5idWlsZFRyYW5zYWN0aW9uKHBlbmRpbmdUcmFuc2FjdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nVHJhbnNhY3Rpb25FcnJvciAmJiByZWplY3QocGVuZGluZ1RyYW5zYWN0aW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB0aGlzLl90aW1lcnMucHVzaCh0aW1lcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduTXVsdGlwbGVUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IHRoaXMuX3dhbGxldDtcbiAgICAgICAgaWYgKCF3YWxsZXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgQ29ubmVjdGVkXCIpO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnM6IHRoaXMuaW5zdHJ1Y3Rpb25zVG9TZXJpYWxpemFibGVJbnN0cnVjdGlvbnModC5pbnN0cnVjdGlvbnMpLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWRlbnRpZmllcjogdXVpZHY0KClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkZW50aWZpZXJzID0gc2VyaWFsaXplZFRyYW5zYWN0aW9ucy5tYXAoKHQpID0+IHQudHJhbnNhY3Rpb25JZGVudGlmaWVyKTtcbiAgICAgICAgdHJhbnNhY3Rpb25JZGVudGlmaWVycy5mb3JFYWNoKCh0cmFuc2FjdGlvbklkZW50aWZpZXIpID0+IHRoaXMuX3BlbmRpbmdUcmFuc2FjdGlvbnNbdHJhbnNhY3Rpb25JZGVudGlmaWVyXSA9IG51bGwpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgd2FsbGV0LnBvc3RNZXNzYWdlKHsgdHlwZTogXCJzaWduQWxsVHJhbnNhY3Rpb25zXCIsIHNpZ25BbGxUcmFuc2FjdGlvbnM6IHsgdHJhbnNhY3Rpb25zOiBzZXJpYWxpemVkVHJhbnNhY3Rpb25zIH0gfSwgdGhpcy51cmwpO1xuICAgICAgICAgICAgY29uc3QgdGltZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdUcmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbklkZW50aWZpZXJzLm1hcCgodHhJZCkgPT4gdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9uc1t0eElkXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ1RyYW5zYWN0aW9uRXJyb3JzID0gdHJhbnNhY3Rpb25JZGVudGlmaWVycy5tYXAoKHR4SWQpID0+IHRoaXMuX3BlbmRpbmdUcmFuc2FjdGlvbkVycm9yc1t0eElkXSk7XG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdUcmFuc2FjdGlvbnMuZXZlcnkoKHQpID0+IHQgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVyKHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwZW5kaW5nVHJhbnNhY3Rpb25zLm1hcCgocHQpID0+IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihwdCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGVuZGluZ1RyYW5zYWN0aW9uRXJyb3JzLnNvbWUoKGUpID0+IGUgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVyKHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHBlbmRpbmdUcmFuc2FjdGlvbkVycm9ycy5maW5kKChlKSA9PiBlICE9IG51bGwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgdGhpcy5fdGltZXJzLnB1c2godGltZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jZW5zb2N1c3RvZHkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@censo-custody/solana-wallet-adapter/lib/esm/censocustody.js\n");

/***/ }),

/***/ "./node_modules/@censo-custody/solana-wallet-adapter/lib/esm/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@censo-custody/solana-wallet-adapter/lib/esm/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _censocustody_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./censocustody.js */ \"./node_modules/@censo-custody/solana-wallet-adapter/lib/esm/censocustody.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _censocustody_js__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _censocustody_js__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNlbnNvLWN1c3RvZHkvc29sYW5hLXdhbGxldC1hZGFwdGVyL2xpYi9lc20vaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0M7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjZW5zby1jdXN0b2R5L3NvbGFuYS13YWxsZXQtYWRhcHRlci9saWIvZXNtL2luZGV4LmpzP2QwNGIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9jZW5zb2N1c3RvZHkuanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@censo-custody/solana-wallet-adapter/lib/esm/index.js\n");

/***/ })

}]);